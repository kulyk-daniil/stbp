## Лабораторна робота № 1 Хешування

Виконав:
студент гр. КН-Н922б
Кулик Д.І.

Перевірив:
Бульба С.С.

## Мета
Дослідити принципи роботи хешування.

## Завдання
Дослідити існуючі механізми хешування. Реалізувати алгоритм гешування SHA (будь-якої версії). Реалізацію інших алгоритмів хешування слід омовити з викладачем.

Довести коректність роботи реалізованого алгоритму шляхом порівняння результатів з існуючими реалізаціями (напр. утилітою sha1sum).

## Хід роботи
SHA-2 (Secure Hash Algorithm 2), частиною якого є SHA-256, є одним із найпопулярніших алгоритмів хешування. Криптографічний хеш, який також часто називають «дайджест», «відбиток пальця» або «підпис», — це майже ідеально унікальний рядок символів, який генерується з окремого фрагмента введеного тексту. SHA-256 генерує 256-бітний (32-байтний) підпис.
Три основні цілі хеш-функцій:
• Детерміновано шифрувати дані (такий вид шифрування завжди створює одне й те саме зашифроване значення для того самого текстового значення);
• Приймати введення будь-якої довжини, а виводити результат фіксованої довжини;
• Змінювати дані не можна. Введення не можна отримати з висновку.
КРОКИ:
1. Попередня робота
2. Ініціалізація значення хеша (h)
3. Ініціалізація округлених констант (k)
4. Цикл фрагментів
5. Створення розкладу повідомлень (w)
6. Стиснення
7. Зміна остаточних значень
8. Фінальний хеш

## Важливі фрагменти програми
Заповнювання
```python
    # Заповнювання
    length = len(message) * 8  # len(message) - це кількість байтів

    message.append(0x80)

    # перетворене повідомлення заповнити нулями доки дані не стануть кратними 512 без останніх 64 біт
    while (len(message) * 8 + 64) % 512 != 0:
        message.append(0x00)

    message += length.to_bytes(8, 'big')  # доповнення до 8 байтів або 64 бітів

    assert (len(message) * 8) % 512 == 0, "Padding did not complete properly!"
```
Створення розкладу повідомлень
```python
        # Створення розкладу повідомлень
        message_schedule = []
        for t in range(0, 64):
            if t <= 15:
                # додає t'те 32-розрядне слово блоку,
                # починаючи з крайнього лівого слова
                # 4 байти за раз
                message_schedule.append(bytes(message_block[t*4:(t*4)+4]))
                # print(message_schedule)
            else:
                term1 = _sigma1(int.from_bytes(message_schedule[t-2], 'big'))
                term2 = int.from_bytes(message_schedule[t-7], 'big')
                term3 = _sigma0(int.from_bytes(message_schedule[t-15], 'big'))
                term4 = int.from_bytes(message_schedule[t-16], 'big')

                # В кінці для нашого масиву байтів виконується додавання по модулю 2^32
                # поки ми не переконаємося, що довжина повідомлення дорівнюватиме 64.
                schedule = ((term1 + term2 + term3 + term4) %
                            2**32).to_bytes(4, 'big')
                message_schedule.append(schedule)

        assert len(message_schedule) == 64
```
Стиснення
```python
        # Запускаємо цикл стиснення, який змінюватиме значення a-h
        # завдяки зсувним та логічним операціям, зазначеним у реалізації SHA-256.
        # Усі розрахунки виконуються 64 рази.
        for t in range(64):
            t1 = ((h + _capsigma1(e) + _ch(e, f, g) + K[t] +
                   int.from_bytes(message_schedule[t], 'big')) % 2**32)

            t2 = (_capsigma0(a) + _maj(a, b, c)) % 2**32

            h = g
            g = f
            f = e
            e = (d + t1) % 2**32
            d = c
            c = b
            b = a
            a = (t1 + t2) % 2**32
```
Зміна значень хешу
```python
        # Після циклу стиснення, але ще всередині основного циклу ми модифікуємо
        # значення хешу, додаючи до них відповідні змінні a-h.
        # Додавання також відбувається за модулем 2^32.
        h0 = (h0 + a) % 2**32
        h1 = (h1 + b) % 2**32
        h2 = (h2 + c) % 2**32
        h3 = (h3 + d) % 2**32
        h4 = (h4 + e) % 2**32
        h5 = (h5 + f) % 2**32
        h6 = (h6 + g) % 2**32
        h7 = (h7 + h) % 2**32
```
## Результати роботи програми

Результати роботи власної реалізації

![Результати роботи власної реалізації](/lab01/doc/my_sha256.png)

Порівняння з онлайн-сервісом обчислення SHA-256

![https://emn178.github.io/online-tools/sha256.html](/lab01/doc/online_sha256.png)

## Висновки
В результаті виконання лабораторної роботи було досліджено принципи роботи хешування. В результаті порівняння власної реалізації алгоритму з вже реалізованими була виявлена ідентичність роботи, що доводить коректність першого.